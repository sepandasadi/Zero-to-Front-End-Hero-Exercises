<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Memory Leak Detection Exercise</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: #f5f7fa;
      padding: 20px;
    }

    .header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 30px;
      border-radius: 12px;
      margin-bottom: 30px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }

    .header h1 {
      margin-bottom: 10px;
    }

    .controls {
      background: white;
      padding: 20px;
      border-radius: 8px;
      margin-bottom: 20px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.05);
    }

    .controls button {
      background: #667eea;
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 6px;
      cursor: pointer;
      margin-right: 10px;
      margin-bottom: 10px;
      font-size: 14px;
      transition: background 0.2s;
    }

    .controls button:hover {
      background: #5568d3;
    }

    .controls button.danger {
      background: #dc3545;
    }

    .controls button.danger:hover {
      background: #c82333;
    }

    .widget-container {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
      gap: 20px;
      margin-bottom: 20px;
    }

    .widget {
      background: white;
      border-radius: 8px;
      padding: 20px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.05);
      transition: transform 0.2s;
    }

    .widget:hover {
      transform: translateY(-4px);
      box-shadow: 0 4px 16px rgba(0,0,0,0.1);
    }

    .widget h3 {
      color: #333;
      margin-bottom: 10px;
    }

    .widget p {
      color: #666;
      margin-bottom: 15px;
    }

    .widget button {
      background: #28a745;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      margin-right: 5px;
    }

    .widget button.delete {
      background: #dc3545;
    }

    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.7);
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }

    .modal.active {
      display: flex;
    }

    .modal-content {
      background: white;
      padding: 40px;
      border-radius: 12px;
      max-width: 500px;
      position: relative;
    }

    .modal-close {
      position: absolute;
      top: 10px;
      right: 15px;
      font-size: 24px;
      cursor: pointer;
      color: #666;
    }

    .animated-box {
      width: 100%;
      height: 200px;
      background: linear-gradient(45deg, #667eea, #764ba2);
      border-radius: 8px;
      margin-top: 20px;
    }

    .stats {
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.05);
    }

    .stats h3 {
      margin-bottom: 10px;
    }

    .stats .stat-item {
      padding: 10px;
      margin: 5px 0;
      background: #f8f9fa;
      border-radius: 4px;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>üêõ Memory Leak Detection Exercise</h1>
    <p>This app has intentional memory leaks. Use DevTools Memory panel to find and fix them!</p>
  </div>

  <div class="controls">
    <button onclick="createWidget()">‚ûï Create Widget</button>
    <button onclick="createMultipleWidgets()">‚ûï Create 10 Widgets</button>
    <button onclick="deleteAllWidgets()" class="danger">üóëÔ∏è Delete All Widgets</button>
    <button onclick="openAnimationModal()">üé® Show Animation</button>
    <button onclick="startHeavyTask()">‚ö° Heavy Task</button>
    <button onclick="forceGC()">‚ôªÔ∏è Force GC (if available)</button>
  </div>

  <div class="widget-container" id="widgetContainer">
    <!-- Widgets will be added here -->
  </div>

  <div class="stats">
    <h3>Stats</h3>
    <div class="stat-item">Widgets created: <span id="widgetCount">0</span></div>
    <div class="stat-item">Active widgets: <span id="activeCount">0</span></div>
    <div class="stat-item">‚ö†Ô∏è Memory leaks: <strong>5+</strong></div>
  </div>

  <div class="modal" id="animationModal">
    <div class="modal-content">
      <span class="modal-close" onclick="closeAnimationModal()">&times;</span>
      <h2>Animated Modal</h2>
      <p>This modal has a memory leak. The animation continues even after closing!</p>
      <div class="animated-box" id="animatedBox"></div>
      <br><br>
      <button onclick="closeAnimationModal()">Close</button>
    </div>
  </div>

  <script>
    // ‚ùå LEAK #1: Detached DOM nodes stored in array
    const widgets = [];

    // ‚ùå LEAK #2: Global cache that grows indefinitely
    const cache = {};

    // ‚ùå LEAK #3: Timer references not cleared
    let animationTimer = null;

    // ‚ùå LEAK #4: Event listeners not removed
    const eventHandlers = new Map();

    let widgetIdCounter = 0;
    let widgetCount = 0;

    function createWidget() {
      const id = ++widgetIdCounter;
      widgetCount++;

      const widget = document.createElement('div');
      widget.className = 'widget';
      widget.id = `widget-${id}`;

      // ‚ùå LEAK: Creating large data that will be captured by closure
      const largeData = new Array(100000).fill(`Data for widget ${id}`);

      widget.innerHTML = `
        <h3>Widget #${id}</h3>
        <p>This widget leaks memory when deleted!</p>
        <button class="action">Click Me</button>
        <button class="delete">Delete</button>
      `;

      // ‚ùå LEAK: Event listener captures large closure
      const clickHandler = function() {
        console.log('Widget clicked!', id);
        // Closure captures entire largeData even though not used!
        console.log('Has data:', largeData.length > 0);
      };

      const deleteHandler = function() {
        deleteWidget(id);
      };

      const actionBtn = widget.querySelector('.action');
      const deleteBtn = widget.querySelector('.delete');

      // ‚ùå LEAK: Adding listeners without cleanup plan
      actionBtn.addEventListener('click', clickHandler);
      deleteBtn.addEventListener('click', deleteHandler);

      // ‚ùå LEAK #1: Storing DOM reference that won't be cleared
      widgets.push({
        id,
        element: widget,
        data: largeData,  // Keeping large data
        clickHandler,
        deleteHandler
      });

      // ‚ùå LEAK #2: Caching data indefinitely
      cache[`widget_${id}`] = {
        data: largeData,
        timestamp: Date.now(),
        metadata: {
          created: new Date().toISOString(),
          largeArray: new Array(50000).fill('cached data')
        }
      };

      document.getElementById('widgetContainer').appendChild(widget);
      updateStats();

      console.log(`Widget ${id} created. Cache size: ${Object.keys(cache).length}`);
    }

    function createMultipleWidgets() {
      for (let i = 0; i < 10; i++) {
        createWidget();
      }
    }

    function deleteWidget(id) {
      const widgetElement = document.getElementById(`widget-${id}`);

      if (widgetElement) {
        // ‚ùå LEAK: Removing from DOM but not from widgets array!
        widgetElement.remove();

        // ‚ùå LEAK: Not removing event listeners!
        // ‚ùå LEAK: Not removing from cache!
        // ‚ùå LEAK: Element still referenced in widgets array!

        widgetCount--;
        updateStats();

        console.log(`Widget ${id} removed from DOM (but still in memory!)`);
      }
    }

    function deleteAllWidgets() {
      const container = document.getElementById('widgetContainer');

      // ‚ùå LEAK: Just clearing innerHTML doesn't clean up references
      container.innerHTML = '';

      // ‚ùå LEAK: Not clearing widgets array!
      // ‚ùå LEAK: Not clearing cache!
      // widgets.length = 0;  // This would help but is commented out
      // Object.keys(cache).forEach(key => delete cache[key]);  // This too

      widgetCount = 0;
      updateStats();

      console.log('All widgets removed from DOM (but data still in memory!)');
      console.log('Widgets array length:', widgets.length);
      console.log('Cache keys:', Object.keys(cache).length);
    }

    function openAnimationModal() {
      const modal = document.getElementById('animationModal');
      modal.classList.add('active');

      const box = document.getElementById('animatedBox');
      let hue = 0;

      // ‚ùå LEAK #3: Timer not cleared when modal closes!
      animationTimer = setInterval(() => {
        hue = (hue + 1) % 360;
        box.style.background = `linear-gradient(45deg,
          hsl(${hue}, 70%, 60%),
          hsl(${(hue + 60) % 360}, 70%, 60%)
        )`;
      }, 16);

      console.log('Animation started (timer will leak!)');
    }

    function closeAnimationModal() {
      const modal = document.getElementById('animationModal');
      modal.classList.remove('active');

      // ‚ùå LEAK: Not clearing the animation timer!
      // clearInterval(animationTimer);  // This would fix it
      // animationTimer = null;

      console.log('Modal closed (but animation timer still running!)');
    }

    function startHeavyTask() {
      console.log('Starting heavy task...');

      // ‚ùå LEAK: Creating large data structures unnecessarily
      for (let i = 0; i < 100; i++) {
        const key = `heavy_${Date.now()}_${i}`;
        cache[key] = {
          data: new Array(100000).fill(`Heavy data ${i}`),
          nested: {
            more: new Array(50000).fill('nested data')
          }
        };
      }

      console.log('Heavy task complete. Cache size:', Object.keys(cache).length);
      console.log('‚ö†Ô∏è Memory usage increased significantly!');
    }

    function forceGC() {
      if (window.gc) {
        window.gc();
        console.log('‚úÖ Forced garbage collection');
      } else {
        console.log('‚ö†Ô∏è GC not available. Run Chrome with --expose-gc flag');
        console.log('Or use the üóëÔ∏è icon in DevTools Memory panel');
      }
    }

    function updateStats() {
      document.getElementById('widgetCount').textContent = widgetIdCounter;
      document.getElementById('activeCount').textContent = widgetCount;
    }

    // ‚ùå LEAK #5: Global interval that accumulates data
    setInterval(() => {
      // Adding data to cache every second
      cache[`background_${Date.now()}`] = {
        timestamp: Date.now(),
        data: new Array(10000).fill('background task data')
      };

      if (Object.keys(cache).length % 100 === 0) {
        console.log('Background task: Cache size:', Object.keys(cache).length);
      }
    }, 1000);

    // ‚ùå LEAK #6: Window event listener never removed
    window.addEventListener('scroll', function() {
      // This closure captures scope unnecessarily
      const temp = new Array(1000).fill('scroll data');
      // Never used but captures memory
    });

    // Initial log
    console.log('üêõ Leaky App Loaded!');
    console.log('üí° Tips for finding leaks:');
    console.log('1. Take a heap snapshot (Snapshot A)');
    console.log('2. Create and delete 10 widgets');
    console.log('3. Force GC, take Snapshot B');
    console.log('4. Repeat: Create and delete 10 more widgets');
    console.log('5. Force GC, take Snapshot C');
    console.log('6. Compare Snapshots A and C - memory should be similar but isn\'t!');
    console.log('7. Search for "Detached" to find detached DOM nodes');
    console.log('8. Look at retaining paths to understand why objects can\'t be freed');
  </script>
</body>
</html>

