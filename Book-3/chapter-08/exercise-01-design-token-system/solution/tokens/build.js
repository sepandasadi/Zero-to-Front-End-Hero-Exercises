const fs = require('fs');
const path = require('path');

// Read tokens from JSON file
const tokensPath = path.join(__dirname, 'tokens.json');
const tokens = JSON.parse(fs.readFileSync(tokensPath, 'utf-8'));

/**
 * Recursively generate CSS variables from nested token object
 * @param {Object} obj - Token object
 * @param {string} prefix - Current prefix for variable name
 * @returns {string} CSS variable declarations
 */
function generateCSS(obj, prefix = '') {
  let css = '';

  for (const [key, value] of Object.entries(obj)) {
    const varName = prefix ? `${prefix}-${key}` : key;

    if (value && typeof value === 'object' && value.value !== undefined) {
      // This is a token with a value
      css += `  --${varName}: ${value.value};\n`;
    } else if (value && typeof value === 'object') {
      // This is a nested object, recurse deeper
      css += generateCSS(value, varName);
    }
  }

  return css;
}

/**
 * Recursively generate Sass variables from nested token object
 * @param {Object} obj - Token object
 * @param {string} prefix - Current prefix for variable name
 * @returns {string} Sass variable declarations
 */
function generateSCSS(obj, prefix = '') {
  let scss = '';

  for (const [key, value] of Object.entries(obj)) {
    const varName = prefix ? `${prefix}-${key}` : key;

    if (value && typeof value === 'object' && value.value !== undefined) {
      // This is a token with a value - use $ for Sass
      scss += `$${varName}: ${value.value};\n`;
    } else if (value && typeof value === 'object') {
      // This is a nested object, recurse deeper
      scss += generateSCSS(value, varName);
    }
  }

  return scss;
}

/**
 * Recursively convert token object to JS-friendly structure
 * @param {Object} obj - Token object
 * @returns {Object} Simplified object with just values
 */
function flattenTokens(obj) {
  const result = {};

  for (const [key, value] of Object.entries(obj)) {
    if (value && typeof value === 'object' && value.value !== undefined) {
      result[key] = value.value;
    } else if (value && typeof value === 'object') {
      result[key] = flattenTokens(value);
    }
  }

  return result;
}

// Generate light mode CSS
const lightModeCSS = `:root {\n${generateCSS(tokens)}}`;

// Generate dark mode CSS (exclude the 'dark' key itself from light mode)
const { dark, ...lightTokens } = tokens;
const lightCSS = `:root {\n${generateCSS(lightTokens)}}`;
const darkCSS = dark ? `\n[data-theme="dark"] {\n${generateCSS(dark)}}` : '';

const fullCSS = lightCSS + darkCSS;

// Generate Sass variables (just light mode)
const scssContent = generateSCSS(lightTokens);

// Generate JavaScript export
const jsTokens = flattenTokens(lightTokens);
const jsContent = `// Auto-generated design tokens
// Do not edit this file directly - edit tokens.json instead

export const tokens = ${JSON.stringify(jsTokens, null, 2)};

export default tokens;
`;

// Write generated files
const outputDir = __dirname;

fs.writeFileSync(path.join(outputDir, 'build.css'), fullCSS, 'utf-8');
console.log('âœ… Generated build.css');

fs.writeFileSync(path.join(outputDir, 'build.scss'), scssContent, 'utf-8');
console.log('âœ… Generated build.scss');

fs.writeFileSync(path.join(outputDir, 'build.js'), jsContent, 'utf-8');
console.log('âœ… Generated build.js');

console.log('\nðŸŽ‰ Token build complete!');
console.log('\nGenerated files:');
console.log('  - build.css (CSS custom properties)');
console.log('  - build.scss (Sass variables)');
console.log('  - build.js (JavaScript export)');

// Count tokens
const countTokens = (obj) => {
  let count = 0;
  for (const [key, value] of Object.entries(obj)) {
    if (value && typeof value === 'object' && value.value !== undefined) {
      count++;
    } else if (value && typeof value === 'object') {
      count += countTokens(value);
    }
  }
  return count;
};

const totalTokens = countTokens(lightTokens);
console.log(`\nðŸ“Š Total tokens: ${totalTokens}`);

