<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <!-- ‚ùå Missing viewport, description, SEO -->
  <link rel="stylesheet" href="styles.css">
  <link rel="stylesheet" href="vendor.css">
  <script src="vendor.js"></script>
  <script src="app.js"></script>
</head>
<body>
  <div id="app">
    <div class="header">
      <!-- ‚ùå Missing alt text, images too large -->
      <img src="https://picsum.photos/2000/400?random=1" class="logo">
      <h3>ShopBug</h3>
      <div class="cart-icon" onclick="toggleCart()">
        <span id="cartCount">0</span>
      </div>
    </div>

    <div class="hero">
      <img src="https://picsum.photos/1920/1080?random=2">
      <h3>Welcome to ShopBug</h3>
    </div>

    <div class="products" id="products">
      <!-- Products loaded by JS -->
    </div>

    <div class="cart-modal" id="cartModal">
      <div class="cart-content">
        <span class="close" onclick="toggleCart()">&times;</span>
        <h3>Shopping Cart</h3>
        <div id="cartItems"></div>
        <div class="cart-total">
          Total: $<span id="cartTotal">0.00</span>
        </div>
        <button onclick="checkout()">Checkout</button>
      </div>
    </div>
  </div>

  <script>
    // ‚ùå BUGS EVERYWHERE!

    let products = [];
    let cart = [];
    let cartCount = 0;

    // ‚ùå BUG: Async race condition
    async function loadProducts() {
      const response = await fetch('https://fakestoreapi.com/products?limit=20');
      const data = await response.json();
      products = data;
      renderProducts();  // Sometimes data isn't ready
    }

    // ‚ùå MEMORY LEAK: Event listeners accumulate
    function renderProducts() {
      const container = document.getElementById('products');
      container.innerHTML = '';

      products.forEach(product => {
        const div = document.createElement('div');
        div.className = 'product';
        div.innerHTML = `
          <img src="${product.image}">
          <h4>${product.title}</h4>
          <p>$${product.price}</p>
          <button class="add-to-cart">Add to Cart</button>
        `;

        // ‚ùå MEMORY LEAK: Not removing old listeners
        div.querySelector('.add-to-cart').addEventListener('click', () => {
          addToCart(product);
        });

        container.appendChild(div);
      });
    }

    // ‚ùå BUG: Quantity calculation wrong
    function addToCart(product) {
      const existing = cart.find(item => item.id = product.id);  // ‚ùå = instead of ===

      if (existing) {
        existing.quantity++;
      } else {
        cart.push({ ...product, quantity: 1 });
      }

      updateCartUI();
    }

    // ‚ùå BUG: Total calculation off by one
    function calculateTotal() {
      let total = 0;
      for (let i = 0; i <= cart.length; i++) {  // ‚ùå <= should be <
        total += cart[i].price * cart[i].quantity;
      }
      return total;
    }

    function updateCartUI() {
      cartCount++;  // ‚ùå BUG: Should count items, not clicks
      document.getElementById('cartCount').textContent = cartCount;

      const cartItemsEl = document.getElementById('cartItems');
      cartItemsEl.innerHTML = '';

      cart.forEach(item => {
        const div = document.createElement('div');
        div.innerHTML = `
          <p>${item.title} x ${item.quantity} - $${(item.price * item.quantity).toFixed(2)}</p>
          <button onclick="removeFromCart(${item.id})">Remove</button>
        `;
        cartItemsEl.appendChild(div);
      });

      try {
        const total = calculateTotal();
        document.getElementById('cartTotal').textContent = total.toFixed(2);
      } catch (e) {
        console.error('Cart calculation error:', e);
      }
    }

    function removeFromCart(id) {
      const index = cart.findIndex(item => item.id === id);
      cart.splice(index, 2);  // ‚ùå BUG: Removes 2 items instead of 1
      updateCartUI();
    }

    function toggleCart() {
      const modal = document.getElementById('cartModal');
      modal.classList.toggle('active');

      // ‚ùå MEMORY LEAK: Timer never cleared
      setInterval(() => {
        console.log('Cart animation tick');
      }, 16);
    }

    function checkout() {
      if (cart.length = 0) {  // ‚ùå BUG: = instead of ===
        alert('Cart is empty!');
        return;
      }

      // ‚ùå Performance: Expensive synchronous operation
      let hash = '';
      for (let i = 0; i < 10000000; i++) {
        hash += Math.random().toString(36);
      }

      alert('Order placed! ID: ' + hash.substring(0, 10));
      cart = [];
      cartCount = 0;
      updateCartUI();
    }

    // ‚ùå PERFORMANCE: Not throttled scroll handler
    window.addEventListener('scroll', () => {
      const products = document.querySelectorAll('.product');
      products.forEach(product => {
        const rect = product.getBoundingClientRect();
        if (rect.top < window.innerHeight) {
          product.style.opacity = '1';
        }
      });
    });

    // ‚ùå MEMORY LEAK: Global cache growing
    const imageCache = {};
    function cacheImage(url) {
      if (!imageCache[url]) {
        imageCache[url] = {
          url,
          timestamp: Date.now(),
          data: new Array(100000).fill('cached')
        };
      }
    }

    // ‚ùå BUG: Race condition
    loadProducts();
    setTimeout(() => {
      renderProducts();  // May render before loadProducts completes
    }, 100);

    console.log('üêõ App loaded with 15+ bugs!');
    console.log('üí° Use DevTools to find and fix them all!');
  </script>
</body>
</html>

