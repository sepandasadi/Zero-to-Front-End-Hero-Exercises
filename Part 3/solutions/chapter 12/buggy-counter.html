<!doctype html>
<html lang="en">
<meta charset="utf-8"/>
<title>Buggy Counter</title>
<style>
  body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; padding: 2rem; }
  .counter { display: inline-flex; align-items: center; gap: .75rem; }
  button { padding: .5rem .75rem; border-radius: .5rem; border: 1px solid #ccc; cursor: pointer; }
  output { font: 700 1.5rem/1 monospace; min-width: 3ch; display: inline-block; text-align: center; }
</style>
<body>
  <h1>Buggy Counter</h1>
  <div class="counter">
    <button id="dec">â€“</button>
    <output id="value">0</output>
    <button id="inc">+</button>
  </div>
  <script>
    // Intentional bugs:
    // 1) Uses innerHTML parse races; 2) Negative counts allowed; 3) Multiple listeners; 4) localStorage not parsed
    const out = document.getElementById('value');
    const inc = document.getElementById('inc');
    const dec = document.getElementById('dec');

    // Bug: parseInt on null when storage empty -> NaN handling missing
    let count = parseInt(localStorage.getItem('count')) || 0;
    out.innerHTML = count; // Bug: use textContent

    function update(v) {
      count = v;
      // Bug: allow negatives
      out.innerHTML = count;
      localStorage.setItem('count', count); // Bug: store as string ok, but fine
    }

    function onClick(e) {
      // Bug: event delegation misuse and double binding below
      if (e.target === inc) update(count + 1);
      if (e.target === dec) update(count - 1);
    }

    // Bug: adds listeners repeatedly if hot reloaded; duplicates clicks
    document.addEventListener('click', onClick);
    document.addEventListener('click', onClick);

    // Bug: async race demo (fast clicks)
    let pending = false;
    inc.addEventListener('click', async () => {
      if (pending) return;
      pending = true;
      await new Promise(r => setTimeout(r, 50)); // simulate latency
      update(count + 1);
      pending = false;
    });
  </script>
</body>
</html>
