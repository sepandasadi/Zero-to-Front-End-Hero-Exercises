<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Memory Leak Fixed - No Leaks!</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: #f5f7fa;
      padding: 20px;
    }

    .header {
      background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
      color: white;
      padding: 30px;
      border-radius: 12px;
      margin-bottom: 30px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }

    .header h1 {
      margin-bottom: 10px;
    }

    .controls {
      background: white;
      padding: 20px;
      border-radius: 8px;
      margin-bottom: 20px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.05);
    }

    .controls button {
      background: #28a745;
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 6px;
      cursor: pointer;
      margin-right: 10px;
      margin-bottom: 10px;
      font-size: 14px;
      transition: background 0.2s;
    }

    .controls button:hover {
      background: #218838;
    }

    .controls button.danger {
      background: #dc3545;
    }

    .controls button.danger:hover {
      background: #c82333;
    }

    .widget-container {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
      gap: 20px;
      margin-bottom: 20px;
    }

    .widget {
      background: white;
      border-radius: 8px;
      padding: 20px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.05);
      transition: transform 0.2s;
    }

    .widget:hover {
      transform: translateY(-4px);
      box-shadow: 0 4px 16px rgba(0,0,0,0.1);
    }

    .widget h3 {
      color: #333;
      margin-bottom: 10px;
    }

    .widget p {
      color: #666;
      margin-bottom: 15px;
    }

    .widget button {
      background: #28a745;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      margin-right: 5px;
    }

    .widget button.delete {
      background: #dc3545;
    }

    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.7);
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }

    .modal.active {
      display: flex;
    }

    .modal-content {
      background: white;
      padding: 40px;
      border-radius: 12px;
      max-width: 500px;
      position: relative;
    }

    .modal-close {
      position: absolute;
      top: 10px;
      right: 15px;
      font-size: 24px;
      cursor: pointer;
      color: #666;
    }

    .animated-box {
      width: 100%;
      height: 200px;
      background: linear-gradient(45deg, #28a745, #20c997);
      border-radius: 8px;
      margin-top: 20px;
    }

    .stats {
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.05);
    }

    .stats h3 {
      margin-bottom: 10px;
    }

    .stats .stat-item {
      padding: 10px;
      margin: 5px 0;
      background: #f8f9fa;
      border-radius: 4px;
    }

    .success {
      background: #d4edda;
      color: #155724;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 20px;
      border: 1px solid #c3e6cb;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>‚úÖ All Memory Leaks Fixed!</h1>
    <p>This app properly manages memory. Compare with the leaky version using DevTools!</p>
  </div>

  <div class="success">
    <strong>‚úÖ All leaks fixed!</strong> Memory remains stable even after extensive use.
  </div>

  <div class="controls">
    <button onclick="createWidget()">‚ûï Create Widget</button>
    <button onclick="createMultipleWidgets()">‚ûï Create 10 Widgets</button>
    <button onclick="deleteAllWidgets()" class="danger">üóëÔ∏è Delete All Widgets</button>
    <button onclick="openAnimationModal()">üé® Show Animation</button>
    <button onclick="startHeavyTask()">‚ö° Heavy Task</button>
    <button onclick="forceGC()">‚ôªÔ∏è Force GC (if available)</button>
  </div>

  <div class="widget-container" id="widgetContainer">
    <!-- Widgets will be added here -->
  </div>

  <div class="stats">
    <h3>Stats</h3>
    <div class="stat-item">Widgets created: <span id="widgetCount">0</span></div>
    <div class="stat-item">Active widgets: <span id="activeCount">0</span></div>
    <div class="stat-item">‚úÖ Memory leaks: <strong>0</strong></div>
  </div>

  <div class="modal" id="animationModal">
    <div class="modal-content">
      <span class="modal-close" onclick="closeAnimationModal()">&times;</span>
      <h2>Animated Modal</h2>
      <p>Animation stops properly when modal closes - no leak!</p>
      <div class="animated-box" id="animatedBox"></div>
      <br><br>
      <button onclick="closeAnimationModal()">Close</button>
    </div>
  </div>

  <script>
    // ‚úÖ FIX #1: Use WeakMap instead of array (auto garbage collection)
    const widgets = new Map();  // Using Map for easy cleanup

    // ‚úÖ FIX #2: LRU cache with size limit
    class LRUCache {
      constructor(maxSize = 100) {
        this.maxSize = maxSize;
        this.cache = new Map();
      }

      set(key, value) {
        if (this.cache.size >= this.maxSize) {
          const firstKey = this.cache.keys().next().value;
          this.cache.delete(firstKey);
        }
        this.cache.set(key, value);
      }

      get(key) {
        const value = this.cache.get(key);
        if (value) {
          this.cache.delete(key);
          this.cache.set(key, value);
        }
        return value;
      }

      delete(key) {
        return this.cache.delete(key);
      }

      clear() {
        this.cache.clear();
      }

      get size() {
        return this.cache.size;
      }
    }

    const cache = new LRUCache(100);  // Max 100 items

    // ‚úÖ FIX #3: Proper timer management
    let animationTimer = null;
    let widgetIdCounter = 0;
    let widgetCount = 0;

    function createWidget() {
      const id = ++widgetIdCounter;
      widgetCount++;

      const widget = document.createElement('div');
      widget.className = 'widget';
      widget.id = `widget-${id}`;

      // ‚úÖ FIX: Only store necessary data
      const necessaryData = { id, timestamp: Date.now() };

      widget.innerHTML = `
        <h3>Widget #${id}</h3>
        <p>This widget cleans up properly!</p>
        <button class="action">Click Me</button>
        <button class="delete">Delete</button>
      `;

      // ‚úÖ FIX: Closure only captures what's needed
      const clickHandler = function() {
        console.log('Widget clicked!', necessaryData.id);
      };

      const deleteHandler = function() {
        deleteWidget(id);
      };

      const actionBtn = widget.querySelector('.action');
      const deleteBtn = widget.querySelector('.delete');

      actionBtn.addEventListener('click', clickHandler);
      deleteBtn.addEventListener('click', deleteHandler);

      // ‚úÖ FIX: Store handlers for cleanup
      widgets.set(id, {
        element: widget,
        data: necessaryData,
        clickHandler,
        deleteHandler,
        actionBtn,
        deleteBtn
      });

      // ‚úÖ FIX: Using LRU cache (auto-limits size)
      cache.set(`widget_${id}`, {
        timestamp: Date.now(),
        metadata: { created: new Date().toISOString() }
      });

      document.getElementById('widgetContainer').appendChild(widget);
      updateStats();

      console.log(`Widget ${id} created. Cache size: ${cache.size}`);
    }

    function createMultipleWidgets() {
      for (let i = 0; i < 10; i++) {
        createWidget();
      }
    }

    function deleteWidget(id) {
      const widgetData = widgets.get(id);

      if (widgetData) {
        // ‚úÖ FIX: Remove event listeners before removing element
        widgetData.actionBtn.removeEventListener('click', widgetData.clickHandler);
        widgetData.deleteBtn.removeEventListener('click', widgetData.deleteHandler);

        // Remove from DOM
        widgetData.element.remove();

        // ‚úÖ FIX: Remove from Map
        widgets.delete(id);

        // ‚úÖ FIX: Remove from cache
        cache.delete(`widget_${id}`);

        widgetCount--;
        updateStats();

        console.log(`Widget ${id} fully cleaned up. Cache size: ${cache.size}`);
      }
    }

    function deleteAllWidgets() {
      // ‚úÖ FIX: Properly clean up each widget
      widgets.forEach((widgetData, id) => {
        // Remove event listeners
        widgetData.actionBtn.removeEventListener('click', widgetData.clickHandler);
        widgetData.deleteBtn.removeEventListener('click', widgetData.deleteHandler);

        // Remove from cache
        cache.delete(`widget_${id}`);
      });

      // Clear container
      document.getElementById('widgetContainer').innerHTML = '';

      // ‚úÖ FIX: Clear the Map
      widgets.clear();

      widgetCount = 0;
      updateStats();

      console.log('All widgets properly cleaned up!');
      console.log('Widgets map size:', widgets.size);
      console.log('Cache size:', cache.size);
    }

    function openAnimationModal() {
      const modal = document.getElementById('animationModal');
      modal.classList.add('active');

      const box = document.getElementById('animatedBox');
      let hue = 0;

      // Clear any existing timer first
      if (animationTimer) {
        clearInterval(animationTimer);
      }

      animationTimer = setInterval(() => {
        hue = (hue + 1) % 360;
        box.style.background = `linear-gradient(45deg,
          hsl(${hue}, 70%, 60%),
          hsl(${(hue + 60) % 360}, 70%, 60%)
        )`;
      }, 16);

      console.log('Animation started');
    }

    function closeAnimationModal() {
      const modal = document.getElementById('animationModal');
      modal.classList.remove('active');

      // ‚úÖ FIX: Clear the animation timer!
      if (animationTimer) {
        clearInterval(animationTimer);
        animationTimer = null;
        console.log('Animation stopped properly');
      }
    }

    function startHeavyTask() {
      console.log('Starting heavy task...');

      // ‚úÖ FIX: Data goes into LRU cache (auto-limited)
      for (let i = 0; i < 100; i++) {
        const key = `heavy_${i}`;
        cache.set(key, {
          timestamp: Date.now(),
          index: i
        });
        // Old items automatically removed when cache is full
      }

      console.log('Heavy task complete. Cache size:', cache.size);
      console.log('‚úÖ Memory remains stable (cache has size limit)');
    }

    function forceGC() {
      if (window.gc) {
        window.gc();
        console.log('‚úÖ Forced garbage collection');
      } else {
        console.log('‚ö†Ô∏è GC not available. Run Chrome with --expose-gc flag');
        console.log('Or use the üóëÔ∏è icon in DevTools Memory panel');
      }
    }

    function updateStats() {
      document.getElementById('widgetCount').textContent = widgetIdCounter;
      document.getElementById('activeCount').textContent = widgetCount;
    }

    // ‚úÖ FIX: No background task accumulating data
    // If we need one, we'd limit what it stores:
    let backgroundDataCount = 0;
    const MAX_BACKGROUND_DATA = 10;

    const backgroundTask = setInterval(() => {
      if (backgroundDataCount < MAX_BACKGROUND_DATA) {
        cache.set(`background_${Date.now()}`, {
          timestamp: Date.now()
        });
        backgroundDataCount++;
      }
      // Stops accumulating after reaching limit
    }, 5000);

    // ‚úÖ FIX: Clean up on page unload
    window.addEventListener('beforeunload', () => {
      console.log('Page unloading - cleaning up...');

      // Clear animation timer
      if (animationTimer) {
        clearInterval(animationTimer);
      }

      // Clear background task
      clearInterval(backgroundTask);

      // Clean up all widgets
      deleteAllWidgets();

      // Clear cache
      cache.clear();
    });

    // Initial log
    console.log('‚úÖ Fixed App Loaded - No Memory Leaks!');
    console.log('üí° Compare memory usage with leaky version:');
    console.log('1. Take heap snapshot');
    console.log('2. Create and delete 50+ widgets');
    console.log('3. Force GC and take another snapshot');
    console.log('4. Memory should return to near-baseline!');
    console.log('5. Search for "Detached" - should find 0 or very few');
    console.log('6. Cache size is limited to 100 items max');

    // Monitor memory (if available)
    if (performance.memory) {
      setInterval(() => {
        const used = (performance.memory.usedJSHeapSize / 1048576).toFixed(2);
        const limit = (performance.memory.jsHeapSizeLimit / 1048576).toFixed(2);
        console.log(`Memory: ${used}MB / ${limit}MB`);
      }, 30000);  // Every 30 seconds
    }
  </script>
</body>
</html>

